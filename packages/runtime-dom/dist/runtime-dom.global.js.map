{"version":3,"file":"runtime-dom.global.js","sources":["../../shared/src/index.ts","../../reactivity/src/effect.ts","../../reactivity/src/baseHandlers.ts","../../reactivity/src/reactive.ts","../../reactivity/src/ref.ts","../../reactivity/src/computed.ts","../../runtime-core/src/vnode.ts","../../runtime-core/src/apiCreateApp.ts","../../runtime-core/src/componentPublicInstance.ts","../../runtime-core/src/component.ts","../../runtime-core/src/apiLifecycle.ts","../../runtime-core/src/scheduler.ts","../../runtime-core/src/renderer.ts","../../runtime-core/src/h.ts","../../runtime-core/src/apiWatch.ts","../src/nodeOps.ts","../src/patchProp.ts","../src/index.ts"],"sourcesContent":["export const isObject = (value) => typeof value == 'object' && value !== null;\nexport const extend = Object.assign;\nexport const isArray = Array.isArray;\nexport const isFunction = (value) => typeof value == 'function';\nexport const isNumber = (value) => typeof value == 'number';\nexport const isString = (value) => typeof value === 'string';\nexport const isIntegerKey = (key) => parseInt(key) + '' === key;\n\nlet hasOwnpRroperty = Object.prototype.hasOwnProperty;\nexport const hasOwn = (target, key) => hasOwnpRroperty.call(target, key);\n\nexport const hasChanged = (oldValue, value) => oldValue !== value;\n\nexport * from './shapeFlag';\n","import { isArray, isIntegerKey } from '@vue/shared/src';\nimport { TriggerOrTypes } from './operators';\n\nexport function effect(fn, options: any = {}) {\n  // 我需要让这个effect变成响应的effect，可以做到数据变化重新执行\n  const effect = createReactiveEffect(fn, options);\n  if (!options.lazy) {\n    // 默认的effect会先执行\n    effect(); // 响应式的effect默认会先执行一次\n  }\n  return effect;\n}\nlet uid = 0;\nlet activeEffect; // 存储当前的effect\nconst effectStack = [];\nfunction createReactiveEffect(fn, options) {\n  const effect = function reactiveEffect() {\n    if (!effectStack.includes(effect)) {\n      // 保证effect没有加入到effectStack中\n      try {\n        effectStack.push(effect);\n        activeEffect = effect;\n        return fn(); // 函数执行时会取值  会执行get方法\n      } finally {\n        effectStack.pop();\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n  effect.id = uid++; // 制作一个effect标识 用于区分effect\n  effect._isEffect = true; // 用于标识这个是响应式effect\n  effect.raw = fn; // 保留effect对应的原函数\n  effect.options = options; // 在effect上保存用户的属性\n  return effect;\n}\n// 让某个对象中的属性 收集当前他对应的effect函数\nconst targetMap = new WeakMap();\nexport function track(target, type, key) {\n  // 可以拿到当前的effect\n  //  activeEffect 当前正在运行的effect\n  if (activeEffect === undefined) {\n    // 此属性不用收集依赖，因为没在effect中使用\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n  }\n}\n\n// 找属性对应的effect 让其执行 （数组、对象）\nexport function trigger(target, type, key?, newValue?, oldValue?) {\n  // 如果这个属性没有收集过effect，那不需要做任何操作\n  const depsMap = targetMap.get(target);\n  if (!depsMap) return; // 只是改了属性 这个属性没有在effect中使用\n\n  const effects = new Set(); // 这里对effect去重了\n  const add = (effectsToAdd) => {\n    // 如果同时有多个 依赖的effect是同一个 还用set做了一个过滤\n    if (effectsToAdd) {\n      effectsToAdd.forEach((effect) => effects.add(effect));\n    }\n  };\n  // 我要将所有的 要执行的effect 全部存到一个新的集合中，最终一起执行\n\n  // 1. 看修改的是不是数组的长度 因为改长度影响比较大 小于依赖收集的长度 要触发重新渲染\n  // 2. 如果调用了push方法 或者其他新增数组的方法(必须能改变长度的方法) 也要触发更新\n  if (key === 'length' && isArray(target)) {\n    // 如果对应的长度 有依赖收集需要更新\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key > newValue) {\n        // 如果更改的长度 小于收集的索引，那么这个索引也需要触发effect重新执行\n        add(dep);\n      }\n    });\n  } else {\n    // 可能是对象\n    if (key !== undefined) {\n      // 这里肯定是修改， 不能是新增\n      add(depsMap.get(key)); // 如果是新增\n    }\n    // 如果修改数组中的 某一个索引 怎么办？\n    switch (\n      type // 如果添加了一个索引就触发长度的更新\n    ) {\n      case TriggerOrTypes.ADD:\n        if (isArray(target) && isIntegerKey(key)) {\n          add(depsMap.get('length'));\n        }\n    }\n  }\n  effects.forEach((effect: any) => {\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect); // 如果有自己提供的scheduler 则执行scheduler逻辑\n    } else {\n      effect();\n    }\n  });\n}\n// weakMap {name:'pf',age:12}  (map) =>{name => set(effect),age => set(effect)}\n// {name:'pf',age:12} => name => [effect effect]\n\n// 函数调用是一个栈型结构\n// effect(()=>{ // effect1   [effect1]\n//     state.name -> effect1\n//     effect(()=>{ // effect2\n//         state.age -> effect2\n//     })\n//     state.address -> effect1\n// })\n\n// 一个属性对应多个effect 一个effect还可以对应多个属性\n//  target key = [effect,effect]\n","// 实现 new Proxy(target, handler)\n\nimport {\n  extend,\n  hasChanged,\n  hasOwn,\n  isArray,\n  isIntegerKey,\n  isObject,\n} from '@vue/shared/src';\nimport { track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOrTypes } from './operators';\nimport { reactive, readonly } from './reactive';\n\nconst get = createGetter();\nconst shallowGet = createGetter(false, true);\nconst readonlyGet = createGetter(true);\nconst showllowReadonlyGet = createGetter(true, true);\nconst set = createSetter();\nconst shallowSet = createSetter(true);\nexport const mutableHandlers = {\n  get,\n  set,\n};\nexport const shallowReactiveHandlers = {\n  get: shallowGet,\n  set: shallowSet,\n};\n\nlet readonlyObj = {\n  set: (target, key) => {\n    console.warn(`set on key ${key} falied`);\n  },\n};\nexport const readonlyHandlers = extend(\n  {\n    get: readonlyGet,\n  },\n  readonlyObj\n);\nexport const shallowReadonlyHandlers = extend(\n  {\n    get: showllowReadonlyGet,\n  },\n  readonlyObj\n);\n\n// 是不是仅读的，仅读的属性set时会报异常\n// 是不是深度的\nfunction createGetter(isReadonly = false, shallow = false) {\n  // 拦截获取功能\n  return function get(target, key, receiver) {\n    // let proxy = reactive({obj:{}})\n    // proxy + reflect\n    // 后续Object上的方法 会被迁移到Reflect Reflect.getProptypeof()\n    // 以前target[key] = value 方式设置值可能会失败 ， 并不会报异常 ，也没有返回值标识\n    // Reflect 方法具备返回值\n    // reflect 使用可以不使用 proxy es6语法\n\n    const res = Reflect.get(target, key, receiver); // target[key];\n    if (!isReadonly) {\n      // 收集依赖，等会数据变化后更新对应的视图\n      console.log('执行effect时会取值', '收集effect');\n\n      track(target, TrackOpTypes.GET, key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isObject(res)) {\n      // vue2 是一上来就递归，vue3 是当取值时会进行代理 。 vue3的代理模式是懒代理\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nfunction createSetter(shallow = false) {\n  // 拦截设置功能\n  // 针对数组而言 如果调用push方法 就会触发两次 1.给数组新增了一项 2.因为更改了长度再次触发set(第二次触发是无意义的)\n  return function set(target, key, value, receiver) {\n    const oldValue = target[key]; // 获取老的值\n\n    // 数组且索引\n    let hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key);\n\n    const result = Reflect.set(target, key, value, receiver); // target[key] = value\n\n    if (!hadKey) {\n      // 新增\n      trigger(target, TriggerOrTypes.ADD, key, value);\n    } else if (hasChanged(oldValue, value)) {\n      // 修改\n      trigger(target, TriggerOrTypes.SET, key, value, oldValue);\n    }\n\n    // 我们要区分是新增的 还是修改的  vue2 里无法监控更改索引，无法监控数组的长度变化  -》 hack的方法 需要特殊处理\n\n    // 当数据更新时 通知对应属性的effect重新执行\n\n    return result;\n  };\n}\n\n// Vue3针对的是对象来进行劫持 不用改写原来的对象 如果是嵌套 当取值的时候才会代理\n// Vue2 针对的是属性劫持 改写了原来对象 一上来就递归\n// Vue3 可以针对不存在的属性进行获取 也会走get方法 proxy支持数组\n","import { isObject } from '@vue/shared';\nimport {\n  mutableHandlers,\n  shallowReactiveHandlers,\n  readonlyHandlers,\n  shallowReadonlyHandlers,\n} from './baseHandlers';\nexport function reactive(target) {\n  return createReactiveObject(target, false, mutableHandlers);\n}\nexport function shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers);\n}\n\nexport function readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers);\n}\n\nexport function shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers);\n}\n\n// 是不是仅读 是不是深度， 柯里化  new Proxy() 最核心的需要拦截 数据的读取和数据的修改  get set\nconst reactiveMap = new WeakMap(); // 目的是添加缓存 会自动垃圾回收，不会造成内存泄漏， 存储的key只能是对象\nconst readonlyMap = new WeakMap();\nexport function createReactiveObject(target, isReadonly, baseHandlers) {\n  // 如果目标不是对象 没法拦截了，reactive这个api只能拦截对象类型\n  if (!isObject(target)) {\n    return target;\n  }\n  // 如果某个对象已经被代理过了 就不要再次代理了  可能一个对象 被代理是深度 又被仅读代理了\n  const proxyMap = isReadonly ? readonlyMap : reactiveMap;\n  const existProxy = proxyMap.get(target);\n  if (existProxy) {\n    return existProxy; // 如果已经被代理了 直接返回即可\n  }\n  const proxy = new Proxy(target, baseHandlers);\n  proxyMap.set(target, proxy); // 将要代理的对象 和对应代理结果缓存起来\n\n  return proxy;\n}\n","import { hasChanged, isArray, isObject } from '@vue/shared/src';\nimport { track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOrTypes } from './operators';\nimport { reactive } from './reactive';\n\nexport function ref(value) {\n  // 将普通类型 变成一个对象 , 可以是对象 但是一般情况下是对象直接用reactive更合理\n  return createRef(value);\n}\n\n// ref 和 reactive的区别 reactive内部采用proxy  ref中内部使用的是defineProperty\nexport function shallowRef(value) {\n  return createRef(value, true);\n}\n\n// 后续 看vue的源码 基本上都是高阶函数 做了类似柯里化的功能\nconst convert = (val) => (isObject(val) ? reactive(val) : val);\n// beta 版本 之前的版本ref 就是个对象 ，由于对象不方便扩展 改成了类 (ts中实现类的话 私有属性必须要先声明才能使用)\nclass RefImpl {\n  public _value; //表示 声明了一个_value属性 但是没有赋值\n  public __v_isRef = true; // 产生的实例会被添加 __v_isRef 表示是一个ref属性\n  constructor(public rawValue, public shallow) {\n    // 参数中前面增加修饰符 标识此属性放到了实例上\n    this._value = shallow ? rawValue : convert(rawValue); // 如果是深度 需要把里面的都变成响应式的\n  }\n  // 类的属性访问器\n  get value() {\n    // 代理 取值取value 会帮我们代理到 _value上\n    track(this, TrackOpTypes.GET, 'value');\n    return this._value;\n  }\n  set value(newValue) {\n    if (hasChanged(newValue, this.rawValue)) {\n      // 判断老值和新值是否有变化\n      this.rawValue = newValue; // 新值会作为老值 用于下次比对\n      this._value = this.shallow ? newValue : convert(newValue);\n      trigger(this, TriggerOrTypes.SET, 'value', newValue);\n    }\n  }\n}\nfunction createRef(rawValue, shallow = false) {\n  return new RefImpl(rawValue, shallow); // 借助类的属性访问器\n}\n\nclass ObjectRefImpl {\n  public __v_isRef = true;\n  constructor(public target, public key) {}\n  get value() {\n    // 代理\n    return this.target[this.key]; // 如果原对象是响应式的就会依赖收集\n  }\n  set value(newValue) {\n    this.target[this.key] = newValue; // 如果原来对象是响应式的 那么就会触发更新\n  }\n}\n// promisify\n// promisifyAll\n\n// 将某一个key对应的值 转化成ref\nexport function toRef(target, key) {\n  // 可以把一个对象的值转化成 ref类型\n  return new ObjectRefImpl(target, key);\n}\n\nexport function toRefs(object) {\n  // object 可能传递的是一个数组 或者对象\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (let key in object) {\n    ret[key] = toRef(object, key);\n  }\n  return ret;\n}\n\n// ref其他方法实现 计算属性\n// effect和reactive和ref的关系\n// computed源码调试\n// vue3的渲染原理 diff算法\n","import { isFunction } from '@vue/shared';\nimport { effect, track, trigger } from './effect';\nimport { TrackOpTypes, TriggerOrTypes } from './operators';\n\nclass ComputedRefImpl {\n  public _dirty = true; // 默认取值时不要用缓存\n  public _value;\n  public effect;\n  constructor(public getter, public setter) {\n    // 返还了effect的执行权限\n    this.effect = effect(getter, {\n      lazy: true, // 默认不执行\n      scheduler: () => {\n        // 传入了scheduler后 下次数据更新 原则上应该让effect重新执行 下次更新会调用scheduler\n        if (!this._dirty) {\n          // 依赖属性变化时\n          this._dirty = true; // 标记为脏 触发视图更新\n          trigger(this, TriggerOrTypes.SET, 'value');\n        }\n      },\n    });\n  }\n  // 如果用户不去计算属性中取值 就不会执行计算属性的effect\n  get value() {\n    // 计算属性也要收集依赖\n    if (this._dirty) {\n      this._value = this.effect(); // 会将用户的返回值返回\n      this._dirty = false;\n    }\n    track(this, TrackOpTypes.GET, 'value'); // 进行属性依赖收集\n    return this._value;\n  }\n  set value(newValue) {\n    // 当用户给计算属性设置值的时候会触发set方法 此时调用计算属性的setter\n    this.setter(newValue);\n  }\n}\n\nexport function computed(getterOrOptoins) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptoins)) {\n    // computed两种写法\n    getter = getterOrOptoins;\n    setter = () => {\n      console.warn('computed value must be readonly');\n    };\n  } else {\n    getter = getterOrOptoins.get;\n    setter = getterOrOptoins.set;\n  }\n  return new ComputedRefImpl(getter, setter);\n}\n","// createVNode  创建虚拟节点\n\nimport { isArray, isObject, isString, ShapeFlags } from '@vue/shared/src';\n\nexport function isVnode(vnode) {\n  return vnode.__v_isVnode;\n}\n\n// h(‘div',{style:{color:red}},'children'); //  h方法和createApp类似\nexport const createVnode = (type, props, children = null) => {\n  // 可以根据type 来区分是组件 还是普通的元素\n  // 根据type来区分 是元素还是组件\n  // 给虚拟节点加一个类型\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : 0;\n\n  const vnode = {\n    // 一个对象来描述对应的内容 ， 虚拟节点有跨平台的能力\n    __v_isVnode: true, // 他是一个vnode节点\n    type,\n    props,\n    children,\n    component: null, // 存放组件对应的实例\n    el: null, // 稍后会将虚拟节点和真实节点对应起来\n    key: props && props.key, // diff算法会用到key\n    shapeFlag, // 判断出当前自己的类型 和 儿子的类型\n  };\n  // 等会做diff算法 肯定要有一个老的虚拟节点(对应着真实的dom)和新的虚拟节点\n  // 虚拟节点比对差异 将差异放到真实节点上\n  normalizeChildren(vnode, children);\n  return vnode;\n};\n\nfunction normalizeChildren(vnode, children) {\n  // 将儿子的类型统一记录在vnode中的shapeFlag\n  let type = 0;\n  if (children == null) {\n    // 没有儿子 不用处理儿子的情况\n  } else if (isArray(children)) {\n    type = ShapeFlags.ARRAY_CHILDREN;\n  } else {\n    type = ShapeFlags.TEXT_CHILDREN;\n  }\n  vnode.shapeFlag |= type;\n}\n\nexport const Text = Symbol('Text');\n\nexport function normalizeVNode(child) {\n  if (isObject(child)) return child;\n  return createVnode(Text, null, String(child));\n}\n","import { createVnode } from './vnode';\n\nexport function createAppAPI(render) {\n  return function createApp(rootComponent, rootProps) {\n    // 告诉他那个组件那个属性来创建的应用\n    const app = {\n      _props: rootProps,\n      _component: rootComponent, // 为了稍后组件挂载之前可以先校验组件是否有render函数\n      _container: null,\n      mount(container) {\n        // 1.根据用户传入的组件生成一个虚拟节点\n        const vnode = createVnode(rootComponent, rootProps);\n        // 2.将虚拟节点变成真实节点 插入到对应的容器中\n        render(vnode, container);\n\n        app._container = container;\n      },\n    };\n    return app;\n  };\n}\n","import { hasOwn } from '@vue/shared/src';\n\nexport const PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    // 取值时 要访问 setUpState， props ,data\n    const { setupState, props, data } = instance;\n    if (key[0] == '$') {\n      return; // 不能访问$ 开头的变量\n    }\n    if (hasOwn(setupState, key)) {\n      // 先自己的状态 再向上下文中查找 再向属性中查找\n      return setupState[key];\n    } else if (hasOwn(props, key)) {\n      return props[key];\n    } else if (hasOwn(data, key)) {\n      return data[key];\n    }\n  },\n  set({ _: instance }, key, value) {\n    const { setupState, props, data } = instance;\n    if (hasOwn(setupState, key)) {\n      setupState[key] = value;\n    } else if (hasOwn(props, key)) {\n      props[key] = value;\n    } else if (hasOwn(data, key)) {\n      data[key] = value;\n    }\n    return true;\n  },\n};\n","// 组件中所有的方法\nimport { isFunction, isObject, ShapeFlags } from '@vue/shared/src';\nimport { PublicInstanceProxyHandlers } from './componentPublicInstance';\n\nlet uid = 0;\nexport function createComponentInstance(vnode) {\n  // webcomponent 组件需要有“属性” “插槽”\n  const instance = {\n    // 组件的实例\n    uid: uid++,\n    vnode, // 实例上的vnode就是我们处理过的vnode\n    type: vnode.type, // 用户写的对象\n    props: {}, // props就是组件里用户声明过的\n    attrs: {}, // 用户没用到的props就会放到attrs中\n    slots: {}, // 组件就是插槽\n    ctx: {}, // 上下文\n    data: {},\n    setupState: {}, // setup返回值\n    emit: null, // 组件通信\n    proxy: null,\n    render: null,\n    subTree: null, // render函数的返回结果就是subTree\n    isMounted: false, // 表示这个组件是否挂载过\n  };\n  instance.ctx = { _: instance }; // 将自己放到了上下文中 instance.ctx._\n  return instance;\n}\n\nexport function setupComponent(instance) {\n  const { props, children } = instance.vnode; // {type,props,children}\n\n  // 初始化属性 initProps\n  // 初始化插槽 initSlots\n  instance.props = props; // initProps()\n  instance.children = children; // 插槽的解析 initSlot()\n\n  // 看当前组件是不是有状态的组件 函数组件\n  let isStateful = instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT;\n  if (isStateful) {\n    // 调用当前实例的setup方法 用setup的返回值 填充setupState和对应的render方法\n    setupStatefulComponent(instance);\n  }\n}\nexport let currentInstance = null;\nexport let setCurrentInstance = (instance) => {\n  currentInstance = instance;\n};\nexport let getCurrentInstance = () => {\n  // 在setuop中获取当前实例\n  return currentInstance;\n};\nfunction setupStatefulComponent(instance) {\n  // 1.代理 传递给render函数的参数\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers as any);\n  // 2.获取组件的类型 拿到组件的setup方法\n  let Component = instance.type;\n  let { setup } = Component;\n  // ------ 没有setup------\n  if (setup) {\n    let setupContext = createSetupContext(instance);\n    currentInstance = instance;\n    const setupResult = setup(instance.props, setupContext); // instance 中props attrs slots emit expose 会被提取出来，因为在开发过程中会使用这些属性\n    currentInstance = null;\n    handleSetupResult(instance, setupResult);\n  } else {\n    finishComponentSetup(instance); // 如果用户没写setup 那么直接用外面的render\n  }\n}\nfunction handleSetupResult(instance, setupResult) {\n  if (isFunction(setupResult)) {\n    instance.render = setupResult;\n  } else if (isObject(setupResult)) {\n    instance.setupState = setupResult;\n  }\n  // 处理后可能依旧没有render 1.用户没写render函数 2.用户写了setup但是什么都没有返回\n  finishComponentSetup(instance);\n}\nfunction finishComponentSetup(instance) {\n  let Component = instance.type;\n  if (!instance.render) {\n    // 对template模板进行编译 产生render函数\n    // instance.render = render;// 需要将生成render函数放在实例上\n    if (!Component.render && Component.template) {\n      // 需要将template变成render函数 compileToFunctions()\n    }\n    instance.render = Component.render;\n  }\n\n  // 对vue2.0API做了兼容处理\n  // applyOptions\n}\nfunction createSetupContext(instance) {\n  return {\n    attrs: instance.attrs,\n    slots: instance.slots,\n    emit: () => {},\n    expose: () => {}, // 是为了表示组件暴露了哪些方法 用户可以通过ref调用哪些方法\n  };\n}\n\n// 他们的关系涉及到后面的使用\n// instance 表示的组件的状态 各种各样的状态，组件的相关信息\n// context 就4个参数 是为了开发时使用的\n// proxy 主要为了取值方便  =》 proxy.xxxx\n","import { currentInstance, setCurrentInstance } from './component';\n\n// 父-》 setup （target = currentInstance = 父）  -> 子 => setup(target = currentInstance = 子)\n// 父 omounted (currentInstance)\nconst enum LifeCycleHooks {\n  BEFORE_MOUNT = 'bm',\n  MOUNTED = 'm',\n  BEFORE_UPDATE = 'bu',\n  UPDATED = 'u',\n}\n\nconst injectHook = (type, hook, target) => {\n  // target指向的肯定是生命周期指向的实例\n  // 后面可能是先渲染儿子 此时currentInstance已经变成渲染儿子了 但是target永远指向是正确的\n  // 在这个函数中保留了实例 闭包\n  if (!target) {\n    return console.warn(\n      'injection APIs can only be used during execution of setup().'\n    );\n  } else {\n    const hooks = target[type] || (target[type] = []); // instance.bm = []\n    const wrap = () => {\n      setCurrentInstance(target); // currentInstance = 自己的\n      hook.call(target);\n      setCurrentInstance(null);\n    };\n    hooks.push(wrap);\n  }\n};\nconst createHook =\n  (lifecycle) =>\n  (hook, target = currentInstance) => {\n    // 全局的当前实例\n    // target用来表示他是哪个实例的钩子\n    // 给当前实例 增加 对应的生命周期 即可\n    injectHook(lifecycle, hook, target);\n  };\n\nexport const invokeArrayFns = (fns) => {\n  for (let i = 0; i < fns.length; i++) {\n    // vue2中也是 调用是 让函数依次执行\n    fns[i]();\n  }\n};\n\nexport const onBeforeMount = createHook(LifeCycleHooks.BEFORE_MOUNT);\nexport const onMounted = createHook(LifeCycleHooks.MOUNTED);\nexport const onBeforeUpdate = createHook(LifeCycleHooks.BEFORE_UPDATE);\nexport const onUpdated = createHook(LifeCycleHooks.UPDATED);\n","let queue = [];\nexport function queueJob(job) {\n  // 批量处理 多次更新先缓存去重 之后异步更新\n  if (!queue.includes(job)) {\n    queue.push(job);\n    queueFlush();\n  }\n}\nlet isFlushPending = false;\nfunction queueFlush() {\n  if (!isFlushPending) {\n    isFlushPending = true;\n    Promise.resolve().then(flushJobs);\n  }\n}\n\nfunction flushJobs() {\n  isFlushPending = false;\n  // 清空时 我们需要根据调用的顺序依次刷新, 保证先刷新父在刷新子\n  queue.sort((a, b) => a.id - b.id);\n  for (let i = 0; i < queue.length; i++) {\n    const job = queue[i];\n    job();\n  }\n  queue.length = 0;\n}\n","import { effect } from '@vue/reactivity/src';\nimport { ShapeFlags } from '@vue/shared/src';\nimport { createAppAPI } from './apiCreateApp';\nimport { invokeArrayFns } from './apiLifecycle';\nimport { createComponentInstance, setupComponent } from './component';\nimport { queueJob } from './scheduler';\nimport { normalizeVNode, Text } from './vnode';\n\nexport function createRenderer(rendererOptions) {\n  // 告诉core 怎么渲染\n\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    nextSibling: hostNextSibling,\n  } = rendererOptions;\n\n  // -------------------组件----------------------\n  const setupRenderEfect = (instance, container) => {\n    // 每次状态变化后 都会重新执行effect 是第一次还是修改的?\n    instance.update = effect(\n      function componentEffect() {\n        // 每个组件都有一个effect， vue3 是组件级更新，数据变化会重新执行对应组件的effect\n        if (!instance.isMounted) {\n          // 初次渲染\n          let { bm, m } = instance;\n          if (bm) {\n            invokeArrayFns(bm);\n          }\n\n          let proxyToUse = instance.proxy;\n          // $vnode  _vnode\n          // vnode  subTree\n          let subTree = (instance.subTree = instance.render.call(\n            proxyToUse,\n            proxyToUse\n          ));\n\n          // 用render函数的返回值 继续渲染\n          patch(null, subTree, container);\n          instance.isMounted = true;\n\n          if (m) {\n            // mounted要求必须在我们子组件完成后才会调用自己\n            invokeArrayFns(m);\n          }\n        } else {\n          console.log('渲染');\n          let { bu, u } = instance;\n          if (bu) {\n            invokeArrayFns(bu);\n          }\n\n          // diff算法（核心 diff + 序列优化 watchApi 生命周期）\n          const prevTree = instance.subTree; // 数据没变的时候的subTree\n          let proxyToUse = instance.proxy;\n          // 再次调用render 此时用的是最新数据渲染出来了\n          const nextTree = instance.render.call(proxyToUse, proxyToUse);\n          instance.subTree = nextTree;\n          patch(prevTree, nextTree, container);\n\n          if (u) {\n            invokeArrayFns(u);\n          }\n        }\n      },\n      {\n        scheduler: queueJob,\n      }\n    );\n  };\n  const updateComponent = (n1, n2, container) => {};\n  const mountComponent = (initialVNode, container) => {\n    // 组件的渲染流程  最核心的就是调用 setup拿到返回值，获取render函数返回的结果来进行渲染\n    // 1.先有实例\n    const instance = (initialVNode.component =\n      createComponentInstance(initialVNode));\n    // 2.需要的数据解析到实例上\n    setupComponent(instance); // state props attrs render ....\n    // 3.创建一个effect 让render函数执行\n    setupRenderEfect(instance, container);\n  };\n  const processComponent = (n1, n2, container) => {\n    if (n1 == null) {\n      // 组件没有上一次的虚拟节点\n      mountComponent(n2, container);\n    } else {\n      // 组件更新流程\n      updateComponent(n1, n2, container); // 更新组件\n    }\n  };\n  // ------------------组件 ------------------\n\n  //----------------- 处理元素-----------------\n  const mountChildren = (children, container) => {\n    for (let i = 0; i < children.length; i++) {\n      let child = normalizeVNode(children[i]);\n      patch(null, child, container);\n    }\n  };\n  const mountElement = (vnode, container, anchor = null) => {\n    // 把虚拟节点变成真实的DOM元素\n    const { props, shapeFlag, type, children } = vnode;\n    let el = (vnode.el = hostCreateElement(type)); // 对应的是真实DOM元素\n\n    if (props) {\n      for (const key in props) {\n        hostPatchProp(el, key, null, props[key]);\n      }\n    }\n    // 父创建完毕后 需要创建儿子\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      hostSetElementText(el, children); // 文本比较简单 直接扔进去即可\n    } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      mountChildren(children, el);\n    }\n    hostInsert(el, container, anchor);\n  };\n  const patchProps = (oldProps, newProps, el) => {\n    if (oldProps !== newProps) {\n      for (let key in newProps) {\n        const prev = oldProps[key];\n        const next = newProps[key];\n        if (prev !== next) {\n          hostPatchProp(el, key, prev, next);\n        }\n      }\n      for (const key in oldProps) {\n        if (!(key in newProps)) {\n          hostPatchProp(el, key, oldProps[key], null);\n        }\n      }\n    }\n  };\n  const patchKeyedChildren = (c1, c2, el) => {\n    // 两方都有儿子 才能称之为diff算法\n    // 能复用的尽可能复用 之前和现在的差异 不一样的要新建或者删除 一样的要复用 复用dom和属性\n    let i = 0; // 都是默认从头开始比对\n    let e1 = c1.length - 1;\n    let e2 = c2.length - 1;\n\n    // 从头开始一个个比 遇到不同就停止 以短的为主 谁先遍历完毕就终止了\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i];\n      if (isSameVNode(n1, n2)) {\n        // 是同一个元素 要比较属性和这两个人的儿子\n        patch(n1, n2, el);\n      } else {\n        break;\n      }\n      i++;\n    }\n\n    // 从尾开始比\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2];\n      if (isSameVNode(n1, n2)) {\n        patch(n1, n2, el);\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n\n    // 如果老的少新的多 需要将新的直接插入即可 无论是头部增加还是尾部增加 都是这个逻辑\n    if (i > e1) {\n      // 老的少新的多 有一方已经完全比对完成了\n      if (i <= e2) {\n        const nextPos = e2 + 1; // 如果是向后追加 e2+1 肯定大于c2的总长度, 如果是向前追加 e2+1 肯定小于c2的长度\n        // 想知道是向前插入 还是向后插入\n        const anchor = nextPos < c2.length ? c2[nextPos].el : null;\n        while (i <= e2) {\n          patch(null, c2[i], el, anchor);\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      // 老的多新的少 有一方已经完全比对完成了\n      while (i <= e1) {\n        unmount(c1[i]);\n        i++;\n      }\n    } else {\n      // 乱序比较(最长递增子序列) 尽可能复用 用新的元素做成一个映射表去老的里找 一样的就复用 不一样的要不插入要不删除\n\n      // 通过i和e1/e2之间的部分进行差异比对\n      let s1 = i;\n      let s2 = i;\n\n      // 正常来说 应该永久的节点做成一个映射表 拿新的节点去找 看一下能否复用\n      // 根据新的节点生成一个索引的映射表\n      const keyToNewIndexMap = new Map(); // Vue3用的是新的做映射表 Vue2用的是老的做映射表 索引: 值weakMap key对象\n      for (let i = s2; i <= e2; i++) {\n        const childVNode = c2[i]; // 获取新的儿子中每一个节点 child\n        keyToNewIndexMap.set(childVNode.key, i);\n      }\n      // 接下来有了映射表之后 我们要知道哪些可以被patch 哪些不能\n\n      // 计算有几个需要被patch\n      const toBePatched = e2 - s2 + 1; // 新的总个数\n      const newIndexToOldIndexMap = new Array(toBePatched).fill(0); // 一个记录是否对比过的映射表\n\n      // 去老的里面查找 看有没有复用的\n      for (let i = s1; i <= e1; i++) {\n        // 循环老的将老的索引记录到newIndexToOldIndexMap(根据索引进行查找)\n        const oldVnode = c1[i]; // 老的虚拟节点 通过老的key去新的映射表里进行查找 如果有就复用\n        let newIndex = keyToNewIndexMap.get(oldVnode.key); // 新的索引 用老的孩子去新的里面找\n\n        if (newIndex === undefined) {\n          // 用老的去新的找 新的里面没有 删除掉这个节点\n          unmount(oldVnode); // 多余的删掉\n        } else {\n          // 这里用新索引的时候 需要减去开头的长度 (新的位置对应的老的位置 如果数组里放的值 >0 说明已经patch过了)\n          newIndexToOldIndexMap[newIndex - s2] = i + 1; // 构建新的索引和老的索引的关系 (用来标记当前所patch过得结构)\n          // 新老的比对 比较完毕后位置有差异\n          patch(oldVnode, c2[newIndex], el);\n          // 如果里面的值是0的话说明新的有老的没有 而且数组里面会记录新的对应老的索引\n        }\n      } // 到这这是新老属性和儿子的比对 没有移动位置\n\n      // 获取最长递增子序列\n      let increasingNewIndexSequence = getSequence(newIndexToOldIndexMap);\n      console.log(increasingNewIndexSequence, '-----');\n\n      let j = increasingNewIndexSequence.length - 1; // 取出最后一个人的索引\n      // 需要移动位置\n      for (let i = toBePatched - 1; i >= 0; i--) {\n        let currentIndex = i + s2; // 获取h位置\n        let childVNode = c2[currentIndex]; // 找到h对应的节点\n        let anchor =\n          currentIndex + 1 < c2.length ? c2[currentIndex + 1].el : null;\n        // 如果以前不存在这个节点就创造出来 进行插入操作\n        if (newIndexToOldIndexMap[i] === 0) {\n          // 创建 如果自己是0说明没有被patch过\n          patch(null, childVNode, el, anchor);\n        } else {\n          // 不是0 说明是已经比对过属性和儿子了\n          if (i !== increasingNewIndexSequence[j]) {\n            hostInsert(childVNode.el, el, anchor); // 复用了节点 dom操作具有移动性 肯定用的是以前的 但是都做了一遍重新插入\n          } else {\n            console.log('这里不做插入了');\n            j--; // 跳过不需要移动的元素 为了减少移动操作 需要这个最长递增子序列算法\n          }\n        }\n      }\n    }\n  };\n  function getSequence(arr) {\n    // 最终的结果是索引\n    const len = arr.length;\n    const result = [0]; // 索引 递增的序列 用二分查找性能高\n    const p = arr.slice(0); // 里面内容无所谓 和原本的数组相同 用来存放索引\n    let start;\n    let end;\n    let middle;\n    for (let i = 0; i < len; i++) {\n      const arrI = arr[i];\n      if (arrI !== 0) {\n        let resultLastIndex = result[result.length - 1];\n        // 取到索引对应的值\n        if (arr[resultLastIndex] < arrI) {\n          p[i] = resultLastIndex; // 标记当前前一个对应的索引\n          result.push(i);\n          continue; // 当前的值比上一个大 直接push 并且让这个人得记录他的前一个\n        }\n        // 二分查找 找到比当前值大的那一个\n        start = 0;\n        end = result.length - 1;\n        while (start < end) {\n          // 重合就说明找到了对应的值 O(logn)\n          middle = ((start + end) / 2) | 0; // 找到中建位置的前一个\n          if (arr[result[middle]] < arrI) {\n            start = middle + 1;\n          } else {\n            end = middle;\n          } // 找到结果集 比当前这一项大的数\n        }\n        // start / end 就是找到的位置\n        if (arrI < arr[result[start]]) {\n          // 如果相同或者比当前的还大就不换了\n          if (start > 0) {\n            // 才需要替换\n            p[i] = result[start - 1]; // 要将他替换的前一个记住\n          }\n          result[start] = i;\n        }\n      }\n    }\n    let len1 = result.length; // 总长度\n    let last = result[len1 - 1]; // 找到了最后一项\n    while (len1-- > 0) {\n      // 根据前驱节点一个个向前查找\n      result[len1] = last;\n      last = p[last];\n    }\n    return result;\n  } // O(nlogn) 性能比较好 O(n^2)\n\n  const unmountChildren = (children) => {\n    for (let i = 0; i < children.length; i++) {\n      unmount(children[i]);\n    }\n  };\n  const patchChildren = (n1, n2, el) => {\n    const c1 = n1.children; // 新老儿子\n    const c2 = n2.children;\n\n    // 老的有儿子 新的没儿子  新的有儿子老的没儿子  新老都有儿子  新老都是文本\n\n    const prevShapeFlag = n1.shapeFlag;\n    const shapeFlag = n2.shapeFlag; // 分别标识过儿子的状况\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      // case1:现在是文本之前是数组\n      // 老的是n个孩子 但是新的是文本\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        unmountChildren(c1); // 如果c1 中包含组件会调用组件的销毁方法\n      }\n      // 两个人都是文本情况\n      if (c2 !== c1) {\n        // case2：两个都是文本\n        hostSetElementText(el, c2);\n      }\n    } else {\n      // 现在是数组   上一次有可能是文本 或者数组\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        // case3:两个都是数组\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          // 当前是数组 之前是数组\n          // 两个数组的比对  -》 diff算法  ***********************\n\n          patchKeyedChildren(c1, c2, el);\n        } else {\n          // 没有孩子  特殊情况 当前是null ， 删除掉老的\n          unmountChildren(c1);\n        }\n      } else {\n        // 上一次是文本\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\n          // case4 现在是数组 之前是文本\n          hostSetElementText(el, '');\n        }\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          mountChildren(c2, el);\n        }\n      }\n    }\n  };\n  const patchElement = (n1, n2) => {\n    // 走到这里说明前后两个元素能复用\n    let el = (n2.el = n1.el);\n\n    // 更新属性 更新儿子\n    const oldProps = n1.props || {};\n    const newProps = n2.props || {};\n\n    patchProps(oldProps, newProps, el);\n    patchChildren(n1, n2, el);\n  };\n  const processElement = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      mountElement(n2, container, anchor);\n    } else {\n      // 元素更新\n      patchElement(n1, n2);\n    }\n  };\n  //----------------- 处理元素-----------------\n\n  // -----------------文本处理-----------------\n  const processText = (n1, n2, container) => {\n    if (n1 == null) {\n      hostInsert((n2.el = hostCreateText(n2.children)), container);\n    }\n  };\n  const isSameVNode = (n1, n2) => {\n    return n1.type === n2.type && n1.key === n2.key;\n  };\n  const unmount = (n1) => {\n    // 如果是组件 调用的组件的生命周期等\n    hostRemove(n1.el);\n  };\n  // -----------------文本处理-----------------\n  const patch = (n1, n2, container, anchor = null) => {\n    // 核心的patch方法\n    // 针对不同类型 做初始化操作\n    const { shapeFlag, type } = n2;\n\n    // 不是初始化才比较两个节点是不是同一个节点 (判断两个元素是否相同 不相同卸载再添加)\n    if (n1 && !isSameVNode(n1, n2)) {\n      // 把以前的删掉 换成n2\n      anchor = hostNextSibling(n1.el);\n      unmount(n1); // 删除老的\n      n1 = null; // 如果n1为空则直接重新渲染\n    }\n\n    switch (type) {\n      case Text:\n        processText(n1, n2, container);\n        break;\n      default:\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n          processElement(n1, n2, container, anchor);\n        } else if (shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n          processComponent(n1, n2, container);\n        }\n    }\n  };\n  const render = (vnode, container) => {\n    // core的核心, 根据不同的虚拟节点 创建对应的真实元素\n\n    // 默认调用render 可能是初始化流程\n    patch(null, vnode, container);\n  };\n  return {\n    createApp: createAppAPI(render),\n  };\n}\n\n// createRenderer目的是创建一个渲染器\n// 框架都是将组件转换成虚拟dom -> 虚拟dom生成真实dom挂载到页面上\n// 最长递增子序列: 如果当前找到的值比末尾大 直接将至添加到后面 如果当前这个值比末尾小 就去序列中通过二分查找的方式将比他大的值替换掉\n// 函数定义的作用域和执行的作用域不是同一个 就会产生闭包\n// 作用域不会产生(js是静态作用域 定义的时候就确定了) 产生的叫上下文\n","import { isArray, isObject } from '@vue/shared';\nimport { createVnode, isVnode } from './vnode';\n\nexport function h(type, propsOrChildren, children) {\n  // 第一个一定是类型 第一个采纳数可能是属性可能是儿子 后面的一定都是儿子 没有属性的情况只能放数组\n  // 一个的情况可以写文本 一个type + 一个文本\n  const l = arguments.length;\n  if (l === 2) {\n    // 如果propsOrChildren是数组 直接作为第三个参数\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n      if (isVnode(propsOrChildren)) {\n        return createVnode(type, null, [propsOrChildren]);\n      }\n      return createVnode(type, propsOrChildren);\n    } else {\n      // 如果第二个参数 不是对象 那一定是孩子\n      return createVnode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.from(arguments).slice(2);\n    } else if (l === 3 && isVnode(children)) {\n      children = [children];\n    }\n    return createVnode(type, propsOrChildren, children);\n  }\n}\n","import { effect } from '@vue/reactivity';\nimport { hasChanged } from '@vue/shared';\n\n// 核心属性flush怎么刷新 immediate是否立即调用\nfunction doWatch(source, cb, { flush, immediate }) {\n  let oldValue;\n  let scheduler = () => {\n    if (cb) {\n      const newValue = runner();\n      if (hasChanged(oldValue, newValue)) {\n        cb(newValue, oldValue);\n        oldValue = newValue;\n      }\n    } else {\n      source(); // watchEffect不用比较新的和老的值 直接触发用户参数执行即可\n    }\n  };\n  let runner = effect(() => source(), {\n    // 默认不是立即执行\n    lazy: true, // 默认不让effect执行\n    scheduler,\n  }); // 批量更新可以缓存到数组中 开一个异步任务 做队列刷新\n  if (immediate) {\n    scheduler();\n  }\n  oldValue = runner();\n}\n\nexport function watch(source, cb, options) {\n  return doWatch(source, cb, options);\n}\n\nexport function watchEffect(source) {\n  return doWatch(source, null, {} as any);\n}\n\n// watch 和 computed对比\n","export const nodeOps = {\n  // 增删改查 元素插入文本 文本创建 文本元素内容设置 获取父亲 获取下一个元素\n  createElement: (tagName) => document.createElement(tagName),\n  remove: (child) => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  insert: (child, parent, anchor = null) => {\n    parent.insertBefore(child, anchor); // 如果参照物为空 则相当于appendChild\n  },\n  querySelector: (selector) => document.querySelector(selector),\n  setElementText: (el, text) => (el.textContent = text),\n  // 文本操作 创建文本\n  createText: (text) => document.createTextNode(text),\n  setText: (node, text) => (node.nodeValue = text),\n  nextSibling: (node) => node.nextSibling,\n  getParent: (node) => node.parentNode,\n  getNextSibling: (node) => node.nextElementSibling,\n};\n","const patchClass = (el, value) => {\n  if (value == null) {\n    value = '';\n  }\n  el.className = value;\n};\n\nconst patchStyle = (el, prev, next) => {\n  const style = el.style; // 获取样式\n  if (next == null) {\n    el.removeAttribute('style'); // 如果新的没有 直接移除样式即可\n  } else {\n    // 老的有新的没有\n    if (prev) {\n      for (let key in prev) {\n        if (next[key] == null) {\n          // 老的有 新的没有 需要删除\n          style[key] = '';\n        }\n      }\n    }\n    for (let key in next) {\n      // 新的需要赋值到style上\n      style[key] = next[key];\n    }\n  }\n};\n\n// 1.给元素缓存一个绑定事件的列表\n// 2.如果缓存中没有缓存过的，而且value有值 需要绑定方法，并且缓存起来\n// 3.以前绑定过需要删除掉，删除缓存\n// 4.如果前后都有，直接改变invoker中value属性指向最新的事件 即可\nconst patchEvent = (el, key, value) => {\n  // 对函数的缓存\n  const invokers = el._vei || (el._vei = {});\n  const exists = invokers[key];\n  if (value && exists) {\n    // 需要绑定事件 而且存在的情况下\n    exists.value = value; // 替换事件 但是不用解绑\n  } else {\n    const eventName = key.slice(2).toLowerCase();\n    if (value) {\n      // 绑定事件\n      let invoker = (invokers[key] = createInvoker(value));\n      el.addEventListener(eventName, invoker);\n    } else {\n      // 以前绑定了 但是没有value\n      el.removeEventListener(eventName, exists);\n      invokers[key] = undefined;\n    }\n  }\n};\n\nfunction createInvoker(value) {\n  const invoker = (e) => {\n    invoker.value(e);\n  };\n  invoker.value = value; // 为了能随时更改value属性\n  return invoker;\n}\n\nconst patchAttr = (el, key, value) => {\n  if ((value = null)) {\n    el.removeAttribute(key);\n  } else {\n    el.setAttribute(key, value);\n  }\n};\n\nexport const patchProp = (el, key, prevValue, nextValue) => {\n  switch (key) {\n    case 'class':\n      patchClass(el, nextValue); // 比对属性\n      break;\n    case 'style':\n      patchStyle(el, prevValue, nextValue);\n      break;\n    default:\n      // 如果不是事件 才是属性\n      if (/^on[^a-z]/.test(key)) {\n        // 事件就是增加和删除 修改 addEventListener\n        patchEvent(el, key, nextValue);\n      } else {\n        // 其他属性 直接使用setAttribute\n        patchAttr(el, key, nextValue);\n      }\n      break;\n  }\n};\n","// 需要支持dom创建的api及属性处理的api\nimport { extend } from '@vue/shared';\nimport { createRenderer } from '@vue/runtime-core';\nimport { nodeOps } from './nodeOps';\n\n// 如果元素一致只是元素发生变化 要做属性的diff算法\nimport { patchProp } from './patchProp';\n\n// 渲染时用到的所有方法\nconst renderOptions = extend({ patchProp }, nodeOps);\n\n// vue中runtime-core提供了核心的方法 用来处理渲染的 他会使用runtime-dom中的api进行渲染\n// runtime-dom主要的作用就是为了抹平平台差异 不同平台对dom操作方式是不同的 将api传入到core core中可以调用这些方法\n// 1.用户窜如组件和属性 2.需要创建组件的虚拟节点(diff算法) 3.将虚拟节点变成真实节点\nexport function createApp(rootComponent, rootProps = null) {\n  const app = createRenderer(renderOptions).createApp(rootComponent, rootProps);\n  let { mount } = app;\n  app.mount = function (container) {\n    // 清空容器的操作\n    container = nodeOps.querySelector(container);\n    container.innerHTML = ''; // 我们在runtime-dom重写的mount方法 会对容器进行情况\n    mount(container); // 函数劫持 AOP切片\n    // 将组件渲染成dom元素 进行挂载\n  };\n  return app;\n}\n\nexport * from '@vue/runtime-core';\n"],"names":["uid"],"mappings":"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"}