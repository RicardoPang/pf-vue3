{"code":"// 实现 new Proxy(target, handler)\r\nimport { extend, hasChanged, hasOwn, isArray, isIntegerKey, isObject, } from '@vue/shared/src';\r\nimport { track, trigger } from './effect';\r\nimport { reactive, readonly } from './reactive';\r\nconst get = createGetter();\r\nconst shallowGet = createGetter(false, true);\r\nconst readonlyGet = createGetter(true);\r\nconst showllowReadonlyGet = createGetter(true, true);\r\nconst set = createSetter();\r\nconst shallowSet = createSetter(true);\r\nexport const mutableHandlers = {\r\n    get,\r\n    set,\r\n};\r\nexport const shallowReactiveHandlers = {\r\n    get: shallowGet,\r\n    set: shallowSet,\r\n};\r\nlet readonlyObj = {\r\n    set: (target, key) => {\r\n        console.warn(`set on key ${key} falied`);\r\n    },\r\n};\r\nexport const readonlyHandlers = extend({\r\n    get: readonlyGet,\r\n}, readonlyObj);\r\nexport const shallowReadonlyHandlers = extend({\r\n    get: showllowReadonlyGet,\r\n}, readonlyObj);\r\n// 是不是仅读的，仅读的属性set时会报异常\r\n// 是不是深度的\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    // 拦截获取功能\r\n    return function get(target, key, receiver) {\r\n        // let proxy = reactive({obj:{}})\r\n        // proxy + reflect\r\n        // 后续Object上的方法 会被迁移到Reflect Reflect.getProptypeof()\r\n        // 以前target[key] = value 方式设置值可能会失败 ， 并不会报异常 ，也没有返回值标识\r\n        // Reflect 方法具备返回值\r\n        // reflect 使用可以不使用 proxy es6语法\r\n        const res = Reflect.get(target, key, receiver); // target[key];\r\n        if (!isReadonly) {\r\n            // 收集依赖，等会数据变化后更新对应的视图\r\n            console.log('执行effect时会取值', '收集effect');\r\n            track(target, 0 /* TrackOpTypes.GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isObject(res)) {\r\n            // vue2 是一上来就递归，vue3 是当取值时会进行代理 。 vue3的代理模式是懒代理\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nfunction createSetter(shallow = false) {\r\n    // 拦截设置功能\r\n    // 针对数组而言 如果调用push方法 就会触发两次 1.给数组新增了一项 2.因为更改了长度再次触发set(第二次触发是无意义的)\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key]; // 获取老的值\r\n        // 数组且索引\r\n        let hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver); // target[key] = value\r\n        if (!hadKey) {\r\n            // 新增\r\n            trigger(target, 0 /* TriggerOrTypes.ADD */, key, value);\r\n        }\r\n        else if (hasChanged(oldValue, value)) {\r\n            // 修改\r\n            trigger(target, 1 /* TriggerOrTypes.SET */, key, value, oldValue);\r\n        }\r\n        // 我们要区分是新增的 还是修改的  vue2 里无法监控更改索引，无法监控数组的长度变化  -》 hack的方法 需要特殊处理\r\n        // 当数据更新时 通知对应属性的effect重新执行\r\n        return result;\r\n    };\r\n}\r\n// Vue3针对的是对象来进行劫持 不用改写原来的对象 如果是嵌套 当取值的时候才会代理\r\n// Vue2 针对的是属性劫持 改写了原来对象 一上来就递归\r\n// Vue3 可以针对不存在的属性进行获取 也会走get方法 proxy支持数组\r\n//# sourceMappingURL=baseHandlers.js.map","references":["/Users/pangjianfeng/code/pf-vue3-source/vue3-render/packages/shared/src/index.ts","/Users/pangjianfeng/code/pf-vue3-source/vue3-render/packages/reactivity/src/effect.ts","/Users/pangjianfeng/code/pf-vue3-source/vue3-render/packages/reactivity/src/operators.ts","/Users/pangjianfeng/code/pf-vue3-source/vue3-render/packages/reactivity/src/reactive.ts"],"map":"{\"version\":3,\"file\":\"baseHandlers.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../packages/reactivity/src/baseHandlers.ts\"],\"names\":[],\"mappings\":\"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\"}"}
